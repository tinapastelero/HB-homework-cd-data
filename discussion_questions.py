discussion_questions.py

"""
RUNTIME

1. The workload for figuring whether a box of animal crackers contains an elephant will be determined by: total number of animal crackers in box and how many elephants there are in the box.

2. 

O(2^n) - least efficient
O(n^2)
O(n log n)
O(n)
O(log n)
O(1) - most efficient


STACKS AND QUEUES

1. Stacks vs Queues:
- The process of loading and unloading pallets onto a flatbed truck - STACK
- Putting bottle caps on bottles of beer as they roll down an assembly line - QUEUE
- Calculating the solution to this mathematical expression: 2 + (7 * 4) - (3 / 2) - QUEUE

2. Queue Examples: processing orders received on Amazon; serving patients that arrive in a doctor's office
3. Stack Examples: reversing a word; washing dishes stacked on a table


LINKED LISTS

1. The nodes are the blocks that say 'apple', 'berry' and 'cherry' with the 'next' pointer. The data for each node are the words 'apple', 'berry' and 'cherry.' The head refers to the 'apple' node (including the next attribute).

2. Singly-linked lists only have data and a 'next' attribute pointing to the node after it. Doubly linked lists have data, a 'next' attribute, and a 'previous' attribute pointing to the node before it. 

3. If you keep track of the tail of a list, you can easily identify which node is the last one, and append to that last node. If you don't have a tail, you will have to spend time to traverse through the whole list to find the end before appending to the list.

TREES 

1. food > mexican > enchiladas > tacos > burrito
2. food > italian > indian > mexican > lasagna > pizza > tikka masala > saag > burrito > tacos > enchiladas > thin crush > Chicago-style
3. In a binary tree, every node has a left node and right node, and all nodes are ordered by some sorting logic. Binary trees are very efficient for searching because each step cuts the possible options in half.

"""
